= Exception Handling

:imagesdir: _images

== Best Practices

=== Checked vs unchecked exceptions
Java defines two kinds of exceptions:

*Checked exceptions*: Exceptions that inherit from the Exception class are checked exceptions. Client code has to handle the checked
exceptions thrown by the API, either in a catch clause or by forwarding it outward with the throws clause.
[NOTE]
====
Use checked exceptions for conditions from which the caller can reasonably be expected to recover.
====

*Unchecked exceptions*: RuntimeException also extends from Exception. However, all of the exceptions that inherit from RuntimeException
get special treatment. There is no requirement for the client code to deal with them, and hence they are called unchecked exceptions.
[NOTE]
====
Use runtime exceptions to indicate programming errors.
====

By way of example, Figure 1 shows the hierarchy for NullPointerException.

image:exception-hierarchy.gif[caption = "Figure 1"]

Figure 1. Sample exception hierarchy

==== What action can the client code take when the exception occurs?
|===
|Client's reaction when exception happens| Exception type

|Client code cannot do anything| Make it an *unchecked exception*
|Client code will take some useful recovery action based on information in exception| Make it a *checked exception*
|===


=== Do not use exceptions for flow control

Generating stack traces is expensive and the value of a stack trace is in debugging. In a flow-control situation, the stack trace would be
ignored, since the client just wants to know how to proceed.

In the code below, a custom exception, MaximumCountReachedException, is used to control the flow. Please never do this:

[source,java]
------
public void useExceptionsForFlowControl() {
    try {
        while (true) {
            increaseCount();
        }
    } catch (MaximumCountReachedException ex) {
    }
    // Continue execution
}

public void increaseCount() throws MaximumCountReachedException {
    if (count >= 5000)
        throw new MaximumCountReachedException();
}
------

=== Never suppress or ignore exceptions
When a method from an API throws a checked exception, it is trying to tell you that you should take some action. If the checked
exception does not make sense to you, do not hesitate to convert it to an unchecked exception and throw it again, but do not ignore it
by catching it with {} and then continue as if nothing had happened.

[source,java]
------
public void someMethod() {
    try {
        ...
    } catch (MaximumCountReachedException ex) {
        // Exception being suppressed, nothing done, neither logging nor rethrowing
    }
}
------

Preferably, you'd do something like this (exception chaining):

[source,java]
------
public void someMethod() {
    try {
        ...
    } catch (SomeException ex) {
        throw new SomeRuntimeException("Something bad happened", ex);
    }
}
------

Or like this:

[source,java]
------
public void someMethod() {
    try {
        ...
    } catch (SomeException ex) {
        LOGGER.log("some message", ex);
    }
}
------

But never forget to include the original exception as a cause to the new one you're raising.

[source,java]
------
public void someMethod() {
    try {
        ...
    } catch (SomeException ex) {
        throw new SomeRuntimeException(ex); // <-- Right
        throw new SomeRuntimeException("Whatever"); // <-- Wrong
    }
}
------

=== Exception inheritance

Try not to create new custom exceptions if they do not have useful information or functionality for client code.

API designers often forget that exceptions are full-fledged objects on which arbitrary methods can be defined.
The primary use of such methods is to provide the code that catches the exception with additional information
concerning the condition that caused the exception to be thrown. In the absence of such methods, programmers have
been known to parse the string representation of an exception to ferret out additional information. This is
*extremely bad practice*.

The following code is discouraged:

[source,java]
------
public class DuplicateUsernameException extends ConcurException {
}
------

This situation is a bit more interesting:

[source,java]
------
public class DuplicateUsernameException extends ConcurException {
    public DuplicateUsernameException(String username) {....}
    public String requestedUsername() {...}
    public String[] availableNames() {...}
}
------

If you don't have anything more important to add, then probably stick to the one exception you
already have, and just create factory methods for being consistent with error messages:

[source,java]
------
public class ConcurException {

    public static ConcurException duplicateUsername(String username) {
        return new ConcurException("The username " + username + " already exists.");
    }
}
------

This way, if you have to throw the exact same issue in a couple of places, at least the message is held in only one place.

=== Factory methods

It's a good idea to have static methods inside exception classes that create instances of the exception using specific messages and error codes, etc.
And then the exception constructor would be private. This way centralizes the creation of exception instances and provides a single place
for managing error messages and error codes in exception creation, this avoiding duplicatoin of messages, or letting other users of the API use the
exception for

[source,java]
------
public class ConcurException extends Exception {

    private static final String INVALID_USERNAME = "Username '%s' doesn't exist.";
    private static final String COMMUNICATION_PROBLEM = "Communication problem: %s.";

    private ConcurException(String message) { // <-- Private
        super(message);
    }

    private ConcurException(String message, Throwable t) { // <-- Private
        super(message, t);
    }

    public static ConcurException invalidUsername(String username) {
        return new ConcurException(String.format(INVALID_USERNAME, username));
    }

    public static ConcurException communicationProblem(String theProblem, Throwable t) {
        return new ConcurException(String.format(COMMUNICATION_PROBLEM, theProblem), t);
    }

    public static ConcurException genericConcurProblem(String message, Throwable t) {
        return new ConcurException(message, t);
    }
}
------


=== Document all exceptions thrown by each method
A description of the exceptions thrown by a method is an important part of the documentation required to use the method properly.

[NOTE]
====
Always *declare checked exceptions individually*, and *document* precisely *the conditions* under which each one is thrown using the Javadoc `@throws` tag.
====

While the language does not require programmers to declare the unchecked exceptions that a method is capable of throwing, it is
wise to document them as carefully as the checked exceptions. Unchecked exceptions generally represent programming errors, and
familiarizing programmers with all of the errors they can make helps them avoid making these errors.

[NOTE]
====
Use the Javadoc `@throws` tag to *document each unchecked exception* that a method can throw, *but do not use the `throws` keyword* to include unchecked
exceptions in the method declaration.
====

[source,java]
------
/**
 * Does something
 *
 * @throws NumberFormatException if the string cannot be parsed as a number
 */
public void someWrongUsageMethod(String numberAsString)
        throws NumberFormatException { // <-- Bad idea
    ...
    Integer.parseInt(numberAsString); // This can throw NumberFormatException
    ...
}

/**
 * Does something
 *
 * @throws NumberFormatException if the string passed contains any non-digit
 */
public void someRightUsageMethod(String numberAsString) {
    if (!numberAsString.matches("\\d+")) {
        throw new NumberFormatException(numberAsString + " is not a number");
    }
}

------

== Additional resources
* link:http://archive.oreilly.com/pub/a/onjava/2003/11/19/exceptions.html[Best Practices for Exception Handling]
* link:http://literatejava.com/exceptions/ten-practices-for-perfect-java-exception-handling/[Ten practices for perfect Java Exception handling]
* Effective Java, 2nd Ed., by Joshua Bloch, Chapter 9: Exceptions
* link:http://www.ibm.com/developerworks/library/j-jtp05236/[Dealing with InterruptedException]


