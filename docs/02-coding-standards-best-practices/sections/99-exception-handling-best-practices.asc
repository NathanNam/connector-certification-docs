= Exception Handling

:imagesdir: _images

== Best Practices

=== Checked vs unchecked exceptions
Java defines two kinds of exceptions:

*Checked exceptions*: Exceptions that inherit from the Exception class are checked exceptions. Client code has to handle the checked
exceptions thrown by the API, either in a catch clause or by forwarding it outward with the throws clause.
[NOTE]
====
Use checked exceptions for conditions from which the caller can reasonably be expected to recover.
====

*Unchecked exceptions*: RuntimeException also extends from Exception. However, all of the exceptions that inherit from RuntimeException
get special treatment. There is no requirement for the client code to deal with them, and hence they are called unchecked exceptions.
[NOTE]
====
Use runtime exceptions to indicate programming errors.
====

By way of example, Figure 1 shows the hierarchy for NullPointerException.

image:exception-hierarchy.gif[caption = "Figure 1"]

Figure 1. Sample exception hierarchy

==== What action can the client code take when the exception occurs?
|===
|Client's reaction when exception happens| Exception type

|Client code cannot do anything| Make it an *unchecked exception*
|Client code will take some useful recovery action based on information in exception| Make it a *checked exception*
|===


=== Do not use exceptions for flow control

Generating stack traces is expensive and the value of a stack trace is in debugging. In a flow-control situation, the stack trace would be
ignored, since the client just wants to know how to proceed.

In the code below, a custom exception, MaximumCountReachedException, is used to control the flow. Please never do this:

[source,java]
------
public void dontUseExceptionsForFlowControl() {
    try {
        while (true) {
            increaseCount();
        }
    } catch (MaximumCountReachedException ex) {
    }
    // Continue execution
}

int count = 0;

public void increaseCount() throws MaximumCountReachedException {
    if (count >= 5000)
        throw new MaximumCountReachedException();
}
------

=== Never suppress or ignore exceptions
When a method from an API throws a checked exception, it is trying to tell you that you should take some action. If the checked
exception does not make sense to you, do not hesitate to convert it to an unchecked exception and throw it again, but do not ignore it
by catching it with {} and then continue as if nothing had happened.

[source,java]
------
public void someMethodSuppressingException() {
    try {
        // ...
    } catch (MaximumCountReachedException ex) {
        // Exception being suppressed, nothing done, neither logging nor rethrowing
    }
}
------

Preferably, you'd do something like this (exception chaining):

[source,java]
------
public void someMethodChainingException() {
    try {
        // ...
    } catch (SomeException ex) {
        throw new SomeRuntimeException("Something bad happened", ex);
    }
}
------

Or, in very rare and hard-to-justify situations, you might do this:

[source,java]
------
public void someMethodLoggingAndNothingMore() {
    try {
        // ...
    } catch (SomeException ex) {
        logger.log("some message", ex);
    }
}
------

But never forget to include the original exception as a cause to the new one you're raising.

[source,java]
------
public void someMethod() {
    try {
        ...
    } catch (SomeException ex) {
        throw new SomeRuntimeException(ex); // <-- Right
        throw new SomeRuntimeException("Whatever"); // <-- Wrong
    }
}
------

=== Exception inheritance

Try not to create new custom exceptions if they do not have useful information or functionality for client code.

API designers often forget that exceptions are full-fledged objects on which arbitrary methods can be defined.
The primary use of such methods is to provide the code that catches the exception with additional information
concerning the condition that caused the exception to be thrown. In the absence of such methods, programmers have
been known to parse the string representation of an exception to ferret out additional information. This is
*extremely bad practice*.

The following code is discouraged:

[source,java]
------
public class DuplicateUsernameException extends ConcurException {
}
------

This situation is a bit more interesting:

[source,java]
------
public class DuplicateUsernameException extends ConcurException {
    public DuplicateUsernameException(String username) {....}
    public String requestedUsername() {...}
    public String[] availableNames() {...}
}
------

If you don't have anything more important to add, then probably stick to the one exception you
already have, and just create factory methods for being consistent with error messages:

[source,java]
------
public class ConcurException {

    public static ConcurException duplicateUsername(String username) {
        return new ConcurException("The username " + username + " already exists.");
    }
}
------

This way, if you have to throw the exact same issue in a couple of places, at least the message is held in only one place.

=== Factory methods

It's a good idea to have static methods inside exception classes for creating the exception with specific messages and error codes.
In this model, the exception constructor would probably be private. This centralizes the creation of exception instances and provides a single place
for managing error messages and error codes, avoiding duplication of messages.

[source,java]
------
public class AwesomeException extends Exception {

    private final String code;
    private final String detail;

    private AwesomeException(String code, String message, String detail) {
        this(code, message, detail, null);
    }

    private AwesomeException(String code, String message, String detail, Throwable t) {
        super(message, t);
        this.code = code;
        this.detail = detail;
    }

    public String getCode() {
        return code;
    }

    public String getDetail() {
        return detail;
    }

    public static AwesomeException invalidUsername(String username) {
        return new AwesomeException("INVALID_USERNAME", String.format("Username '%s' doesn't exist.", username),
                "The username you provided doesn't exist. Did you type it correctly? Please check your credentials and try again.");
    }

    public static AwesomeException communicationProblem(String theProblem, Throwable t) {
        return new AwesomeException("COMMUNICATION_PROBLEM", String.format("Communication problem: %s.", theProblem),
                "There has been a communication problem. This could be a transient issue. Is your cable plugged in? Is Internet working for you? Please try to Google something and validate you're really connected to the Internet.",
                t);
    }

    public static AwesomeException genericProblem(String message, Throwable t) {
        return new AwesomeException("GENERIC_PROBLEM", message,
                "There has been a generic problem. Please contact a system administrator so he can check the logs and determine what's going on", t);
    }
}
------


=== Document all exceptions thrown by each method
A description of the exceptions thrown by a method is an important part of the documentation required to use the method properly.

[NOTE]
====
Always *declare checked exceptions individually*, and *document* precisely *the conditions* under which each one is thrown using the Javadoc `@throws` tag.
====

While the language does not require programmers to declare the unchecked exceptions that a method is capable of throwing, it is
wise to document them as carefully as the checked exceptions. Unchecked exceptions generally represent programming errors, and
familiarizing programmers with all of the errors they can make helps them avoid making these errors.

[NOTE]
====
Use the Javadoc `@throws` tag to *document each unchecked exception* that a method can throw, *but do not use the `throws` keyword* to include unchecked
exceptions in the method declaration.
====

[source,java]
------
/**
 * Does something
 *
 * @throws NumberFormatException if the string cannot be parsed as a number
 */
public void someWrongUsageMethod(String numberAsString)
        throws NumberFormatException { // <-- Bad idea
    ...
    Integer.parseInt(numberAsString); // This can throw NumberFormatException
    ...
}

/**
 * Does something
 *
 * @throws NumberFormatException if the string passed contains any non-digit
 */
public void someRightUsageMethod(String numberAsString) {
    if (!numberAsString.matches("\\d+")) {
        throw new NumberFormatException(numberAsString + " is not a number");
    }
}

------

== Additional resources
* link:http://archive.oreilly.com/pub/a/onjava/2003/11/19/exceptions.html[Best Practices for Exception Handling]
* link:http://literatejava.com/exceptions/ten-practices-for-perfect-java-exception-handling/[Ten practices for perfect Java Exception handling]
* Effective Java, 2nd Ed., by Joshua Bloch, Chapter 9: Exceptions
* link:http://www.ibm.com/developerworks/library/j-jtp05236/[Dealing with InterruptedException]


