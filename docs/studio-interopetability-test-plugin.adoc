== Introduction
The following framework consists of a series of automation tools, which allow you to run interoperability tests on a connector in Anypoint Studio. The data used by these tests  generates using not only the connectors code, but also DevKit output files, in particular the schema and editors file.

All cases described in the +++<u>Interoperability Test Guidelines</u>+++  should be considered depending on the connector’s nature. This means, all the applicable test cases detailed there must be covered for a full interoperability test of the connector.

*Note*: The Anypoint Studio plugin covers only the following cases: 
 * +++<u>Connectivity testing</u>+++
 * +++<u>Datamapper compliance</u>+++ 
 * +++<u>Xml generation</u>+++

== Glossary
 * Runner platform: Host where the test run will take place.
 * Target platform: Describes the platform (in terms of Studio plugins) on which tests are going to we run. 
 * CUT: Connector under test
*-test-data.xml +
*-test-data-override.xml

== Installation 
=== Step 1: Check System Requirements
 * +++<u>Maven 3.2+</u>+++
 * +++<u>Java 1.7</u>+++
 * +++<u>Anypoint Studio</u>+++
=== Step 2: Anypoint Devkit Plugin
Follow these steps on the Runner Platform's Anypoint Studio installation:
 . Click *Help* > *Install New Software*.
 . Click *Anypoint Addons Update Site* from the *Work with* drop-down. *Note*: If this item is not in the dropdown, click *Add* and specify the name, and for the URL, use: http://studio.mulesoft.org/r3/addons/beta
 . Click the checkbox for *Anypoint DevKit Plugin*, and click *Next, Next*, *Finish*. 
 . Restart Anypoint Studio when prompted.
 . Confirm you have Maven installed:
 .. Open the Anypoint Studio preferences (on a Mac, click *Anypoint Studio* > *Preferences*, on a Windows computer, click *Window* > *Preferences*). 
 .. Navigate to *Anypoint Studio* > *Maven Settings* and ensure that the Maven installation home directory points to the directory where you installed Maven. 
 .. Click *Test Maven Configuration* to ensure that Maven is correctly configured.

== Interop Test Run Tutorial
=== Step 1: Anypoint Connector Project in Workspace
If you have an existing connector project, import it into Anypoint Studio with this command: +
mvn eclipse:eclipse +
Import the project as *Anypoint Connector Project from External Location*

=== Step 2: Generating Test Data Files
If you are not familiar with testData files used for interop testing, refer to +++<u>Appendix B</u>+++. +
Right-click the name of your connector in the Package Explorer and click  +
*Anypoint Connector *>* Generate Tests*:



The *Tests Scaffolding Generation* dialog lets you select the operations in scope and the different files type of tests, functional or interoperability, that the required test data files generate:



Interop Test Data Generation setup:
 . Click the *Select All* button. The generation considers all available message processors of the connector.
 . Under Studio Interop Tests, check *Generate Interop Test Data Files*
 . Leave the default test data filename *interop-testdata.xml* or define one of your own. The default behavior in case of finding matching filenames on the output folder is to update them. 
 . Credentials File expected input is the path to a .properties file, which is used to determine which Configuration Element fields are required for authentication. The effects of this can be seen on the <connectorName>-testData-override.xml file. For example .properties contains:

salesforce.username=salesforce.username.value +
salesforce.password=salesforce.password.value +
salesforce.securityToken=salesforce.securityToken.value +
salesforce.url=salesforce.url.value

This generates a config element on the <connectorName>-testData-override.xml file such as:

<config name="config"> +
  <attributes> +
    <attribute name="username" use="required" caption="Username"  +
      group="Connection" type="string" javaType="java.lang.String"    +
      prefix="salesforce">salesforce.username.value</attribute> +
    <attribute name="password" use="required" caption="Password"  +
      group="Connection" type="password" javaType="java.lang.String"  +
      prefix="salesforce">salesforce.password.value</attribute> +
    <attribute name="securityToken" use="required" caption="Security Token" +
      group="Connection" type="string" javaType="java.lang.String"  +
      prefix="salesforce">salesforce.securityToken.value</attribute> +
    <attribute name="url" use="required" caption="Url" group="Connection"  +
      type="string" javaType="java.lang.String"  +
      default="https://login.salesforce.com/services/Soap/u/31.0" +
      prefix="salesforce">salesforce.url.value</attribute> +
  </attributes> +
</config>
=== 
The result of this command should be the following files (see Files section for details):  +
_- nameOfOutputFile.xml _ +
Basic data retrieved from the connector. Provides a complete view of every processor and all its attributes.

_- nameOfOutputFile-override.xml_ +
Presents a subset of the data found in the previous file, with only the required fields, but adds information about the connector and processor features and properties

For this tutorial, <testDataFilename>.xml and <testDataFilename>-override.xml files are the result of the Tests Scaffolding Generation process for Studio Interop Tests. Generated files are placed on src/test/resources/generated.

=== Step 3: Customizing Test Data Files
After the testData and testData-override files are created (+++<u>details about this files in Appendix B</u>+++), the next step is to populate the content from your domain model. This implies the completion of valid inputs for the operations and configurations, and the validation of the retrieved data. 
	
==== Attention Points 
 * Properties detected must be checked and asserted: 
 ** The fact that the connector has connectivity support must be validated. If your connector does not support connectivity, but it was detected as a supported feature, you’ll have to double check your code.
 ** If the connector has OAuth support, then connectivity detection must be false.
 ** If the connector has OAuth support, then metadata detection should not be dynamic.
 ** For each processor, _query-support_ and _auto-paging_ properties should be coherent with the expected values.
 ** Required fields, both in the config and in the processors should be coherent with the expected values declared in the processor declaration. Those annotated with @Optional should be _optional_, everything else should be _required_.

 * Datamapper input/output fields: 
 ** Datamapper Input and Output attributes in each processor represent the values you expect to see at design time when you drop the connector before and after a datamapper element. This values should be empty only if you expect to see nothing in DataMapper.
 ** In a dynamic metadata case, the value of input/output attributes will be bound to the value with which the operation is feeded. 
For example, with dynamic metadata, if you have: 
|===
| <properties>

|===

The output value is bounded to the value declared in the type chooser as follows:
		
*Case Account*
|===
| <properties>

|===
		*Case Contact*
|===
|<properties>

|===

 ** If metadata model is static, then the expected value should be the initial one, with _“List<Map>”_ as the output value.
=== Step 4: Run Interop Tests
	
In Studio, right-click the project and click *Anypoint Connector *>* Run Interop Tests*:

		

The Interop Remote Runner Properties menu shows the existing testData files that were created previously, and a set of options: 
 * Tests to run:  Select which kind of test to run on your connector.
 ** Connectivity
 ** Data Mapper
 ** Xml Generation

 * Verbose Mode
 ** Enables debugging logs on the test runs
	

	
The results appear in target/surefire-reports, and provide jUnit results using the XML result file.
=== 
=== 
== Appendix A: Usage without Studio

=== Annotations Processor
 When the profile is invoked, a custom annotations parser is hooked into the compilation. This processor goes through the connector and its processor code and annotations, retrieving information about the connectors properties, the return types of each processor, etc.

For example, this is the output for the NetSuite connector's properties: 

<properties> +
    <connectivity-support>true</connectivity-support> +
    <OAuth-authentication>false</OAuth-authentication> +
    <transformer>false</transformer> +
    <datasense-enabled>true</datasense-enabled> +
    <metadata>dynamic</metadata> +
 </properties>

This data is found in the root directory of the connector's project, with the name_ annotations-output.xml. _

=== TestData Maven Plugin
This plugin takes the output files from the annotations processor, the DevKit’s generated schema and editors file, and a credentials file. 

The only file that should be fed to the plugin via the command line is the credentials file, needed to identify the required connection fields. Also through the command line, the output file name can be defined.

=== Usage
	To generate the testdata files, build the connector with these arguments:

		*mvn clean package -P testdata-generator -Dtype=interop <params>...*

	Valid options: +
	-DcredentialsFile=”path/to/credentials” +
		-DoutputFile=”nameOfOutputFile.xml” +
-DlogLevel=debug +
-DreplaceAll=true

	The results of this command are the following files (see Files section for details):  +
_- nameOfOutputFile.xml _ +
Basic data retrieved from the connector. Provides a complete view of every processor and all its attributes.

_- nameOfOutputFile-override.xml_ +
Presents a subset of the data found in the previous file, with only the required fields, but adds information about the connector and processor features and properties

Both create in _src/test/resources/generated. _

If the *_replaceAll_*__ __flag is set, *existing files* in the path with the same name *are* completely *overwritten*. 

The format of the credentials file should be: _connectorName.fieldName=fieldValue_

For example, for salesforce we have: +
		salesforce.username=user +
salesforce.password=psswrd +
salesforce.securityToken=token +
salesforce.url=https://login.salesforce.com/services/Soap/u/28.0

The convention to follow is src/test/resouces/salesforce-credentials.properties. 

=== Tests Run From Console 
In the connector root folder, run: +
	*mvn org.mule.connectors.interop:interop-ce-runtime-generation:create*

Followed by: +
	*mvn org.mule.connectors.interop:interop-ce-runtime-generation:run -D[options]*

Valid options:	 +
-DtestConnect -DtestDMapper -DtestXml +
-DtestDataPath=... +
-DtestDataOverridePath=...

== Appendix B: Plugin Result Files 
The following files show the differences between the two files: +
+++<u>https://gist.github.com/alegmarra/cc81e680165c9406c84d</u>+++
==== 
==== TestData (Basic File)
This file contains a detailed description of the connector processors and configs, the fields each of them receives, the hierarchy of child objects, and information about the element representation in AnyPoint Studio.

===== Processor Tags
<get-contacts> and <save-contact> represent each one a processor present in the connector. Everything inside this tag references this particular processor.

===== Attributes, Optional, and Required Tags
Represents the parameters the processor receives that are not childElements. An <optional> tag indicates that the parameter has been annotated as @Optional in the processors declaration, while a <required> tag marks the parameter as mandatory for every execution.

Node attributes like caption, group, javaType, and type, indicate the properties of each parameter and its representation in Studio. Group, caption, and type are needed to find the element in the Studio UI, and successfully populate the form.

===== ChildElements tag
Allows a complete description of the object. This element has a direct mapping with the description done manually in Studio. This elements can be, optional or required, with the same meaning as before.

The “complex” definitions implies each field populates separately, while a “useReference” definition references an object described separately in the flow, just like we do in Studio.
 
==== TestData Overrides (Overrides File)
This template is a merge between a subset of the basic file, and the output from the annotations processor, resulting in a file with not only the whole structure of the connector, for each config and processor, all the required fields are declared, but also a description of the connector and its processors properties. 

The empty attributes and childElements tags mean that this particular processor has no required parameters. 

===== Connector Properties

|===
|*Property*|*Description*

|Connectivity Support|Indicates if the connector implements connectivity testing.
|OAuth Authentication|Indicates if the connector implements OAuth authentication.
|DataSense Enabled|Indicates if the connector supports DataSense.
|Metadata|Declares the kind of metadata the connector supports. Valid values are:  
|Transformer|Indicates if the connector is available also as a transformer
|===

===== Processor Properties

|===
|*Property*|*Description*

|DataMapper|Declares the expected types for datamapper to retrieve from the connector. The DataMapper fields are completed from the connectors code during the testdata generation. 
|Auto Paging|Indicates the processor implements auto paging.
|Query Support|Indicates the processor has at least one attribute annotated as @Query.
|===

			

== Project Details

=== Rules and Conditional Execution 
	
==== ConditionalExecutionRule 
	
Based on a +++<u>jUnit rule</u>+++, it relates to the annotations present on the code. The ConnectorsTestCase abstract class declares a @ClassRule of this type, and also every subclass declares a @Rule. The ClassRules execute before each class is run, and common Rules execute before each method invokes. 

This gracefully skips tests and test classes, by adding an annotation @ConditionalExecutionRule and the conditions it must verify and deny. For example, these testsl run only if the connector has no metadata and doesn’t use OAuth authentication:
	
@ConditionalExecutionRule( verify = { HasNoMetadata.class }, +
				      deny = { UsesOAuthConfiguration.class }) +
	@Test +
	public void myConditionalTest(){ +
	... +
}
==== 
==== Rules Conditions
	
Rule conditions are the classes fed to the conditional executions annotation. The conditions encapsulate the logic around its title. 

For example, instead of skipping a test by saying: +
	assumeThat(!processor.getRequiredAttributes().isEmpty());

Create a condition that implements _RuleCondition_ encapsulating the logic. Then, we can annotate the tests with a ConditionalExecution annotation, with the same result than before: +
 @ConditionalExecutionRule( verify = { ProcessorHasRequiredFields.class }}
	

=== 

=== Test Suites 
	
==== ConnectorTestSuite
	
Use with the jUnit suite class, grouping together the TestClasses to be run with the data from a single connector. Declare which connector to test by passing the routes to its testdata files. 

It’s important to add all available test classes (below), since this suite is the same for every connector. The next section shows how tests that are not applicable are skipped based on the connectors properties.

==== Test Cases
	
The test cases covered so far include +++<u>ConnectivityTesting</u>+++, +++<u>DamapperCompliance</u>+++, and +++<u>XmlGeneration</u>+++, as described in the Connectors QA Guideline. Each of these classes inherit from ConnectorTestCases, which provides utility methods and scaffolding that simplifies test writing.

In every class we have a me	thod annotated with +++<u>@Parameters</u>+++, that injects the parameterized data one element at a time for the suite to run. 

For example, the tests in DatamapperTestCases class run once for each +
processor present in the connector. This can be seen in the method dataProvider, that returns a collection with pairs of (processorName, processorInstance), which are exactly the pair of values its constructor receives.

==== ConnectivityTestCases

 * *-testConnectivity_InvalidCredentials*: Populates the configuration with invalid credentials, running the connectivity test once for each field. Every run has only one invalid value.

 * *-testConnectivity_NoneRequiredSet*: Leaves all the required fields of the configuration empty

 * *-testConnectivity_ValidCredentials*: Populates the configuration with valid credentials in all the required fields.

 * *-testConnectivityButtonIsAvailable: *Verifies the "Test Connectivity" button is visible in the config dialog

 * *-testPasswordFieldHasHiddenText*: Verifies the password field does not show the input in plain text
==== DatamapperTestCases
Preconditions: The configuration and operation are populated with valid data in all the required fields. 

 * *-testEmptyMetadataRetrieved()*_: _Runs only if the connector doesn’t have static nor dynamic metadata. Verifies neither input nor output types are retrieved with datamapper.

 * *-testOverrideMetadata_Input(): *As described in the +++<u>Connectors QA Guideline</u>+++, verifies that manual override allows the selection of the expected type.

 * *-testOverrideMetadata_Output(): *Idem input.

 * *-testPerceptiveFlowDesign(): *As described in the +++<u>Connectors QA Guideline</u>+++, verifies the Datamapper automatic metadata population is achieved with the expected values.

==== XmlGenerationTestCases
 * -*testXmlAllRequiredSet_DefinedAttributes_NoErrorFound()*: Populates the operation required attributes with valid values using the complex type definition of the child elements (if the operation has any). 

 * *-testXmlAllRequiredSet_ReferencedAttributes_NoErrorFound(): *Populates the operation required attributes with valid values using the referenced type definition of the child elements (if the operation has any). 

 * *-testXmlNoneRequiredSet_ErrorsFound(): *Leaves all the required fields empty, so errors should be found.
