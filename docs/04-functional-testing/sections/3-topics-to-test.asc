[[_test_methods]]
==== Topics to Test using CTF

Testing a connector operations is achieved in an easy way using the CTF, as detailed within its documentation. Extra aspects, such as Metadata, Pagination and WSDL operations, are detailed in this section.

===== MetaData Testing

DataSense allows a connector to gather metadata from the remote service in design time, enabling Anypoint developers to deal with actual object types and objects descriptions, instead of generic types.

In order to test MetaData (also known as DataSense within Anypoint Studio), two operations are provided by the connector dispatcher. This scenario is illustrated in the following test example.

[source,java]
----
public class WSDLTestCase extends AbstractTestCase {

  @Category({FunctionalTest.class})
	@Test
	@MetadataTest
	public void testGetMetaDataKeys() throws Exception{

    	Result<List<MetaDataKey>> metaDataKeysResult = dispatcher.fetchMetaDataKeys();

			assertTrue(Result.Status.SUCCESS.equals(metaDataKeysResult.getStatus()));
	        List<MetaDataKey> metaDataKeys = metaDataKeysResult.get();

	    for (MetaDataKey key : metaDataKeys) {
	    	if (accountKey == null && key.getId().equals("Account")) {
	    		accountKey = key;
	    	}
	    	if (contactKey == null && key.getId().equals("Contact")) {
	    		contactKey = key;
	    	}
	    }

	    assertNotNull(accountKey);
	    assertNotNull(contactKey);

	    Result<MetaData> accountKeyResult = dispatcher.fetchMetaData(accountKey);
			assertTrue(Result.Status.SUCCESS.equals(accountKeyResult.getStatus()));

			Result<MetaData> contactKeyResult = dispatcher.fetchMetaData(contactKey);
			assertTrue(Result.Status.SUCCESS.equals(contactKeyResult.getStatus()));
	}
}
----

The connector dispatcher exposes two methods, *fetchMetaDataKeys()* and *fetchMetaData(keyName)*. The first one fetches all keys from the MetaData underlying service, while the second one retrieves the descriptor for a particular MetadataKey.

It is important to notice that MetaData test cases *need to be annotated* with *MetaDataTest*.

===== @Paginated methods

There are different features in Mule, such as pagination, that requires a slightly different approach when testing them.

A connector method can be annotated as @Paged, which means that when calling that method, several calls to the underlying API will be generated so as to avoid retrieving a possible big set of results in one API call. As a result, the user will consume the entire set of results with a single call to the method, although Mule will automatically generate different API calls.

Let's consider that we have a _Query(..)_ method, which is annotated as @Paged and defined as:

[source,java]
----
@Processor
@OAuthProtected
@Category(name = "Category name", description = "A description here.")
@Paged
public ProviderAwarePagingDelegate<Map<String, Object>, Connector> query(@Query @Placement(group = "Query") final String query, final PagingConfiguration pagingConfiguration, @Placement(group = "SOAP Headers") @FriendlyName("Headers") @Optional final Map<Header, Object> headers) {
...
}
----

In order to test this paginated method with CTF, we enable the following mechanism within the test:

[source,java]
----
public class WSDLTestCase extends AbstractTestCase {
  @Before
	public void setUp() throws Exception {

		JobInfo jobInfo = connector.createJob(OperationEnum.insert, "Account", "Id", ContentType.XML, ConcurrencyMode.Parallel);
		jobId = jobInfo.getId();
	}

  @Category({FunctionalTest.class})
	@Test
	public void testQuery() throws Exception{

		List<String> queriedRecordIds = sObjectsIds;
		List<String> returnedSObjectsIds = new ArrayList<String>();

		Object[] args = new Object[] { "SELECT Id, Name, FROM Account WHERE BillingCity = 'Chicago'", null, null };

		Collection<Map<String, Object>> list = (Collection<Map<String, Object>>) dispatcher.runPaginatedMethod("query", args);

		int count = 0;
		Iterator<Map<String, Object>> iter = list.iterator();
		while (iter.hasNext()) {
			Map<String, Object> sObject = iter.next();
			returnedSObjectsIds.add(sObject.get("Id").toString());
			count++;
		}

		assertTrue(returnedSObjectsIds.size() > 0);
		assertEquals(count, list.size());

		for (int index = 0; index < queriedRecordIds.size(); index++) {
			assertTrue(returnedSObjectsIds.contains(queriedRecordIds.get(index).toString()));
		}
	}
}
----

This test extract illustrates how pagination works. If we try to execute connector.Query(...), a runtime exception *UnsupportedMethodAnnotationException* will be thrown by CTF. We need to used the dispatcher instead, which exposes a *runPaginatedMethod(methodName, args)*. The first parameter is the method name (camel-like), while the second is the list of parameter taken by the method in the same order as defined in its signature. In this case the first parameter is the query itself, while the last two parameters (a PagingConfiguration instance and a Map of headers) are not present.

It is important to notice that we provide a mechanism to test operations annotated with @Paged, which indirectly tests the underlying pagination mechanism. However, testing how the pagination mechanisms works, _i.e._ testing the number of pages retrieved and the values within each page should not be performed with the testing framework, since most likely it is a unit test and not a functional test.

===== WSDL Operation Testing

Testing WSDL operations is supported by CTF, achieving an easy testing mechanism. WSDL operations consume WSDL files mapped as XMLStreamReader files, which must be generated within the TestDataBuilder as usual.

However, these WSDL files must be organized as follows:

. _src/test/resources/payloads.xml:_ Must contain all required WSDL-XML files, which are consumed by the TestDataBuilder.
. _WSDL_ID#Operation:_ Every WSDL-XML file must be named as the WSDL ID following the separator _#_ and ending with the operation name.

Testing WSDL operations is supported by means of the following method:

[source,java]
----
public class WSDLTestCase extends AbstractTestCase {

    @Category({FunctionalTest.class})
    @Test
    public void execute() throws Exception {

        XMLStreamReader request = TestdataBuilder.getXMLStreamReaderForAParticularTest();

        ConnectorDispatcher<Connector> dispatcher = getDispatcher();

        XMLStreamReader XMLStreamResult = dispatcher.invokeWsdlOperation(request, "<WSDL_ID>", "<OperationName>");

        //Asserts on XMLStreamResult
    }
----

This is a simple example illustrating how the testing framework supports WSDL operations with a single method. The first parameter is the XMLStreamReader input based on a specific WSDL-XML. The second argument is the WSDL_ID to be used, while the last one stands for the operation name. If your connector does not include multiple service definitions, you need to opt for using the variant of the method without the WSDL_ID as follows:

[source,java]
----
public class WSDLTestCase extends AbstractTestCase {

    @Category({FunctionalTest.class})
    @Test
    public void execute() throws Exception {

        XMLStreamReader request = TestdataBuilder.getXMLStreamReaderForAParticularTest();

        ConnectorDispatcher<Connector> dispatcher = getDispatcher();

        XMLStreamReader XMLStreamResult = dispatcher.invokeWsdlOperation(request, "<OperationName>");

        //Asserts on XMLStreamResult
    }
----
