
Development best practices and coding standars have been learned within the connector developemt community over time, leading to improve the quality of connectors. During the cerfitication process, most of these practices and standars are checked through automated tools, such as SonarQube.


== Anypoint™ Connector DevKit Version

The last version of Anypoint™ Connector Devkit must be used to develop your connector. As of March 2015, the latest stable Devkit version is 3.6.1.

DevKit 3.6.x assures that a connector will be compatible with Mule ESB 3.5.x and Mule ESB 3.6.x. However, external libraries employed by the connector might have conflicts with different Mule ESB versions. Samity checks are mandatory for every Mule ESB Version.

== Connector Category

There are four types of categories with different support policies: Premium, Select, Standard and Community. A connector should define its category within the Maven properties. Further information about connector categories can be found https://www.mulesoft.com/downloads/legal/mule-esb-support-maintenance-term[here].

== Code Conventions

This subsection covers the following areas:

//* Standard Java Coding Conventions
* Maven Conventions and Setup
* DevKit Standards and Best Practices
* Connector Demo Example



//== Standard Java Coding Conventions

//=== Static Analysis Rules

//We have defined as set of static inspections rules that are enforced by SonarQube. This rules are aimed to detect potential bugs and bad coding practices.
//More details about this could be found in the section <<static-code-analysis-and-coverage,Static Code Analysis & Code Coverage>>

== Maven Conventions and Setup

The following section describes set of conventions and best practices to follow at the time to define your connector Maven project structure.

=== Best Practices
A connector tested in an isolated environment might not work in a Mule environment. Therefore, different constrains apply:

* Follow http://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html[Maven default name conventions].
* Do not overwrite org.mule.tools.devkit:mule-devkit-parent properties.
* Do not reference SNAPSHOT dependencies in plugins or dependencies.

=== Multi Module Layout
In large Maven projects, it is a common practice to divide the project in submodules. This means you may end up with a module for your connector and other modules for utils, commons or other kind of modularized source code that will be consumed by the connector.


//This means you can have separated dependencies, different plugins and a different build configuration, no weird single jar references and consistent versioning. Also separate testing and easy-to-extend structure.

Consider the following use-case:

**Project parent pom**

[source, xml]
----
<groupId>org.mule.modules</groupId>
<artifactId>mule-module-sample-connector-parent</artifactId>
<version>1.0.0-SNAPSHOT</version>
<name>Mule Sample Connector Parent</name>
<packaging>pom/packaging>

<modules>
    <module>some-util-lib</module>
    <module>rehusable-service-adapter</module>
    <module>mule-connector-sample</module>
</modules>
----

In your connector's module pom.xml:

**Connector sibling dependencies**

[source, xml]
----
<dependencies>
    <dependency>
        <groupId>org.mule.modules</groupId>
        <artifactId>some-util-lib</artifactId>
        <version>1.0.0-SNAPSHOT</version>
    </dependency>
    <dependency>
        <groupId>org.mule.modules</groupId>
        <artifactId>rehusable-service-adapter</artifactId>
        <version>1.0.0-SNAPSHOT</version>
    </dependency>
</dependencies>
----

It is important to notice that your connector's pom inherits from __mule-devkit-parent__, and that each of the other sub-modules inherits from the project parent. Therefore, you will have:

**Pom extra modules**

[source, xml]
----
<artifactId>some-util-lib</artifactId>
<packaging>jar</packaging>

<parent>
    <groupId>org.mule.modules</groupId>
    <artifactId>mule-module-sample-connector-parent</artifactId>
    <version>1.0.0-SNAPSHOT</version>
</parent>
...
----

[source, xml]
----
<artifactId>rehusable-service-adapter</artifactId>
<packaging>jar</packaging>

<parent>
    <groupId>org.mule.modules</groupId>
    <artifactId>mule-module-sample-connector-parent</artifactId>
    <version>1.0.0-SNAPSHOT</version>
</parent>
...
----

**Connector's pom**

[source, xml]
----
<artifactId>mule-connector-sample</artifactId>
<name>Mule Sample Connector</name>
<packaging>mule-module</packaging>

<parent>
    <groupId>org.mule.tools.devkit</groupId>
    <artifactId>mule-devkit-parent</artifactId>
    <version>3.6.0</version>
</parent>

----

This mix of pom inheritance and agregation allows you to mantain a general parent pom for your secondary modules, and control the compilation in a single point, while leaves the connector with the required devkit-parent pom, making sure that all the other modules will be installed in your local repository before building the connector.

In multi-module projects, the deployment of the artifacts will vary depending on the connector's category. Rule-of-thumb is that the parent pom and all the secondary modules (not the connector module) should be deployed to a public nexus repository, while the connector artifact will override its parent dependency management configuration with its own repository rules.

=== *Avoid caching*
Connectors should not hold state, unless is strictly necessary. Several APIs are actually hosted in cloud environments, and therefore caching states ends up in having untrusted data in the connector.
There are a few cases where the connector might need to save some data of the current API while working on it, which leads into caching.

For those scenarios where the connector needs caching, the following code should be used:

[source,java]
----
// 1) The connector asks for the manager of the Object Store
@Inject
protected ObjectStoreManager objectStoreManager;
----
And then uses the manager to get/create a custom Object Store as follow:
[source,java]
----
// 2) The connector asks Mule for the Object Store represented by a "given ID"
ObjectStore<? extends Serializable> os = objectStoreManager.getObjectStore("given ID");
// 3) The connector uses it
os.store("key", "value");
----

Other ways to achieve caching could be through temporal files, but it might depend on the use case.

=== Avoid spawning threads
Same as caching, spawning threads is not recommended within a connector as a common API lives in the cloud. This means that a connector will not improve its throughput with more threads, because every communication with the API means more HTTP requests/responses. Although we don't recommend using threads, as caching, there might be custom cases where they are actually needed.

For those scenarios where the connector needs to spawn threads you should use a http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorService.html[Executor Service].

=== Reading resources from within the connector
When reading resources that are bundled with the connector, the usual `getClass().getResourceAsStream("custom-file-to-read.txt")` will work. But, if the file `"custom-file-to-read.txt"` can actually be parametrized through the Mule application, then other mechanism should be used.

Let's consider that for your connector, a file can be feeded from the src/main/resources folder (again, this file comes from Studio, not from the connector), the following code should be used:
[source,java]
----
// 1) The connector asks for the manager of the mule context
@Inject
protected MuleContext muleContext;
----
Then reads the resources as follow:
[source,java]
----
ClassLoader classLoader = muleContext.getExecutionClassLoader();
URL resourceURL = classLoader.getResource("custom-file-to-read.txt");
----
Where `"custom-file-to-read.txt"` is the file to be read from the Mule app in `src/main/resources/custom-file-to-read.txt`.

=== Mule dependencies
Adding dependencies in your connector should be carefully considered, since they might collide with Mule.
A few constraints apply, such as:

1. When adding Mule artifacts, always use `<scope>provided</scope>`.
2. When adding artifacts that might collide with Mule, choose versions that are in the current Mule versios, for what your connector is going to work with. Some of those artifacts are: cxf, jersey, spring, guava, etc.

=== Shading
For some corner cases, you might need to add a dependency that does collide with Mule. For those scenarios, we strongly recommend to use the same version of the library as Mule does, and if impossible, then change your library to another one.
If you still need that custom library that collides with Mule, then shading could work for you. The support for shading has been added in devkit 3.5.3.

You need to modify your connector's `pom.xml` file to add the shading plugin in order to achieve two things: 1) add the custom jar into the connector's one and 2) rename the packages of the library into a new one in order to avoid collisions.

The following snippet should work when using a library with the groupId `org.some.library` and the artifactId `custom-artifact-id`

[source, xml]
----
<dependencies>
    <dependency>
        <groupId>org.some.library</groupId>
        <artifactId>custom-artifact-id</artifactId>
        <version>2.0</version> <!-- version to be included in the connector jar -->
    </dependency>
</dependencies>

<!- rest of the configuration -->

<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-shade-plugin</artifactId>
            <version>2.3</version>
            <configuration>
                <!-- custom shade configuration -->
                <artifactSet>
                    <includes>
                        <include>org.some.library:custom-artifact-id</include>
                    </includes>
                </artifactSet>
                <relocations>
                    <relocation>
                        <pattern>org.some.library</pattern>
                        <shadedPattern>org.some.library.new.pakage.name.shade</shadedPattern>
                    </relocation>
                </relocations>
             </configuration>
        </plugin>

        <!-- Other plugins -->
    </plugins>
</build>
----
Further explanation can be found http://maven.apache.org/plugins/maven-shade-plugin/examples/includes-excludes.html[here].

=== Connector Structure

If you create your connector project using the DevKit Studio Plugin, the generated project directory layout is the recommended approach.
If you are interested in more details, the project directory structure is described link:attachments/project-directory-layout.html[here].

In order to provide automatic enforcement of this rules, the following plugin must be configure as part of the connectors pom.xml. We will be responsible for validating the project structure.

Copy and paste the following snippets in your connector pom.xml:

[source,xml]
----
<build>
    ...
    <plugins>
        ...
       <plugin>
            <groupId>org.mule.certification</groupId>
            <artifactId>project-structure-validation</artifactId>
            <version>1.0.4</version>
            <executions>
                <execution>
                    <phase>package</phase>
                    <goals>
                        <goal>validate</goal>
                    </goals>
                </execution>
            </executions>
        </plugin>
        ...
    </plugins>
    ...
</build>
----

== DevKit Standards and Best Practices

=== DataMapper Compliance
To have the best experience in Anypoint™ Studio, connectors must be DataMapper compliant. To achieve this, all operations must follow these recommendations.

Any argument, returned or received, must be one of the following data types:
. Map
. POJO
. List<Map>
. List<String>
. List<POJO>
. List<List<String>>

These types must be part of the method signature so that DataMapper can auto-recognize the types in it's mapping UI.

__Important__: Only use a map if you cannot use a POJO.
Only use a map if your data:
. Is schemaless, for example if created using MongoDB.
. Has user customizable schemas, if created with Salesforce.
. Has unknown content.


|===
|Good Example| Bad Example

|List<Map> query()| List<DBObject> query
|void send(Invoice invoice)| void send(Object object)
|Invoice getInvoice(String id)| Object get(String id, Class typeToCreate)

All operations must have a single object to take input from DataMapper. The object must be a single object, not multiple arguments. This object is called the Primary argument.
|===
|===
|Good Example| Bad Example

|void createInvoice(Invoice invoice)| createInvoice(Header header, List<LineItems> lineItems)
|void upsert(List<Map> sobjects, String type, String externalFieldId)| N/A - Multiple arguments are still needed!
|GetTaxResult getTax(TaxRequest request)|
```public GetTaxResult getTax(String companyCode, +
    AvalaraDocumentType docType, +
    @Optional String docCode, +
    Date docDate, +
    @Optional String salespersonCode, +
    String customerCode, +
    @Optional String customerUsageType, +
    String discount, +
    @Optional String purchaseOrderNo) +
```
|===

=== Annotations
If you have multiple arguments, annotate the Primary argument with:

`@Default("#[payload]")`

This way DataMapper knows which argument in the operation to use for mapping.

=== No Warning during compilation

DevKit does a intensive analysis of the used annotations and semantic of them in conjunction with others. It’s important the the code is free of compilation warning to help on the maintainability of the code and to follow good practices.
=== DevKit Generated API Doc

Connector documentation is composed of two different type of documentation: DevKit Generated DevKit API Doc and the Connector Documentation.

DevKit API Doc is automatically generated by DevKit based on the JavaDoc documentation at the connector class. This is one of the most important information used by the developer at the time of using the connector.

// @Todo: Hernan - Que sugeris ?. LDAP. We need to explain how to check the generated documentation.
// Recomendation with Samples


== Connector Demo Example

// @Todo: Paulo - Here we need to complete with Justin's input feedback.


A Mule application's endpoints allow a user to interact with the service and API using the connector. Endpoints are committed to the GitHub repository along with source code. Use services or API use cases to determine which connector operations to select.

Guidelines to follow:

* All demo projects *must* be isolated in a folder with a descriptive name (It does not matter if is just only one demo). Eg: https://github.com/mulesoft/magento-connector/tree/develop/demo
* Use a meaningful name for the project. Avoid things such as "my-connector-demo" or "example-1". This name will be displayed in the ApiDoc site. Eg: http://mulesoft.github.io/salesforce-connector/
* The demo name *must* have middle lines to separate the words in it and must be in lower case. example: "mail-service-demo" 
* Don't add prefix such as "mule" or "app". Just the purpose of it.
* Ensure that an app can be run by entering credentials without additional configuration or connector installation.
* Use placeholders for credentials.
* Ensure that flow names and message processors display names that make the use case easy to understand.
* Provide instructions on how to run the app in a README file (for example, https://github.com/mulesoft/s3-connector/tree/develop/demo/S3-connector-demo[S3]). It is recommended to add in a description of the demo application, such as what it aims to demonstrate and what each step of the demo is responsible for. Where application, you can also mention where your demo fits in a larger usecase.
* Expose a set of endpoints that the user can access following the steps in the README to reproduce a use case.
* Consider implementing a CRUD (or similar) use case with chained processors whose payloads get logged into the Studio console (for example, https://github.com/mulesoft/s3-connector/tree/develop/demo/S3-connector-demo[S3]).
* Use DataMapper for Standard or Premium connectors' CRUD (or a similar) use case if API methods attributes and/or return types allow it.
* Consider basic error handling in the Mule app.

There are two kinds of demos that you can create:

* Single operation demos
* Workflow demos

Single operation demos are used to invoke just one operation in the connector. Workflow demos are used to invoke a number of operations in the connector sequentially. These aim to show a simple usecase of the connector, such as a normal CRUD workflow. We provide two templates to help you create an interface for your demo, one for each kind of demo. You can find the template for single operation demos link:assets/single-operation-demo-template.html[here] and the template for the workflow demos link:assets/workflow-demo-template.html[here].

The demo HTML pages above make use of Twitter Bootstrap to present a clean interface to the user. You should base your demo on this template. If you are not familiar with the Twitter Bootstrap library, it is highly suggested to look at http://getbootstrap.com/getting-started/[their documentation page]. Single operation demos only provide a form, whereas workflow demos provide an accordion, where one step leads to the next. In the latter case, any values retrieved by the first step should be used to autofill values in the second step where possible.

As an example, let us take a CRUD workflow for a number of Twitter API calls. The first step will create a tweet and return a number of values pertaining to the tweet that was created. One of these values would be the Tweet ID. The second step would be the "read" operation. The tweet ID should be automatically filled in the second step so that the user is simply able to submit a "read" API call without any needed input. The final step of the workflow should present an alert (or a notification of some sort), that the workflow has ended, outputting any relevant information from the last step. An example of this would be a "Tweet Deleted" message if the workflow was completed successfully, and the tweet that was created in the first step is successfully removed.

The following code snippets explain some parts of the above HTML page. 
The demo contains 3 parts:

* The JavaScript that handles asynchronous calls to the demo running on a Mule instance.
* The CSS that renders the HTML page
* The HTML itself

**The JavaScript**

The JavaScript for this demo is simply used to send AJAX calls to a Mule server that hosts your demo application. In the case of workflow demos, it is also used to collapse the accordions as the user goes from one step to the next.

Initially, a reference to the <div> and <form> elements is obtained. 

[source,javascript]
------
var createDiv   = $('#createDiv');
var readDiv     = $('#readDiv');
var updateDiv   = $('#updateDiv');
var deleteDiv   = $('#deleteDiv');

var createForm  = $('#createForm');
var readForm    = $('#readForm');
var updateForm  = $('#updateForm');
var deleteForm  = $('#deleteForm');
------

Then, each form is paired with a jQuery function sends an AJAX request whenever a form is submitted.

[source,javascript]
------
createForm.submit(function() {
  $.ajax({
    type: 'POST',                             // Submit an HTTP POST request
    url: '/create',                           // The URL where your endpoint is listening
    data: createForm.serialize(),             // Serialized form URL-encoded input
    success: function(data) {                 // Success function called if request succeeds
        
      $('input[name=message]').val(data.message); // Autofill data in the next workflow step as needed
        
      createDiv.collapse('hide');             // Hide current accordion window
      readDiv.collapse('show');               // Show next accordion window
    },
    error: function(request, status, error){  // Error function is executed if an exception occurs in the flow
      alert(request.responseText);            // Alert the user of any errors
    }
  });

  return false;                               // Let jQuery handle the form submission
}); 
------

In the case of a workflow demo, every form will represent a step in the workflow. The above code snippet should be repeated for every form you have in your workflow, applying changes as needed.

**The CSS**

The HTML page linked above comes with a number of CSS presets that you can use throughout your demo. A number of Bootstrap CSS classes are also used to build the accordion and the panels within it. For more information on how to build your own accordion, or even extend the one in the HTML template, please refer to the http://getbootstrap.com/javascript/#collapse-example-accordion[Bootstrap Accordion documentation page].

**The HTML**

This part is what ties everything together. The HTML represents what your users will see when they open your demo to use your connector. Take this HTML snippet as an example:

[source,html,options="nowrap"]
-------
<div class="panel-group" id="accordion">
    <div class="panel panel-default">
        <div class="panel-heading">
            <h2 class="panel-title demo-heading">
                <a data-toggle="collapse" data-parent="#accordion" href="#createDiv">Create</a>
            </h2>
        </div>
        <div id="createDiv" class="panel-collapse collapse in">
            <div class="panel-body">
                <form id="createForm" class="demo-form" role="form" >
                    <label>Message</label>
                    <input type="text" name="message" value="Hello from Mule!" required class="form-control" ><br>
                    <input class="btn btn-lg btn-primary btn-block" type="submit" value="Create"><br>
                </form>
            </div>
        </div>
    </div>
    ...
</div>
-------

The above snippet of HTML is taken from the workflow demo template, it represents a single panel in the accordion. This panel is split into two parts: the header and the content. The header refers to the content through the anchor tag (<a>). When this header is clicked, the content is shown. On the other hand, the content is composed of a simple form that is used to submit requests to Mule. These requests are handled by the JavaScript shown above.

For a complete example of a workflow demo, you can download a sample project that uses MongoDB link:assets/workflow-operations-demo.zip[here].
